/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stdio.h>
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include"gpio.h"
#include"header.h"
#include"task.h"

task_t task[MAX_TASK];
uint8_t currentTask = 0;
uint32_t global_count = 0;
void led_init()
{
	pinMode(0, A, output);
//	pinOutput(0, A, high);
	pinMode(2, A, output);
//	pinOutput(2, A, high);
	pinMode(4, A, output);
//	pinOutput(4, A, high);
	pinMode(13, C, output);
//	pinOutput(13, C, low);
}
int main(void)
{
#if 1
	led_init();
	enableAllFaultMonitoring();
	scheduler_stack_init();
	task_stack_init();
	dummy_stack_init();
	systick_init();
	sp_to_psp();
	task1();
#endif

	/* Loop forever */
	for (;;)
		;
}
void schedule()
{
	volatile uint32_t *const ptr = (uint32_t*) ICSR;
	*ptr |= (1 << 28);
}
void task_delay(uint32_t tick_count)
{
	if (currentTask != (MAX_TASK - 1))
	{
		task[currentTask].blockCount = global_count + tick_count;
		task[currentTask].currentState = blocked;
		schedule();
	}
}

void task_stack_init()
{
//	task[0].stack_startAddr = TASK1_STACK_START;
	task[0].PSP = TASK1_STACK_START;
	task[0].pFun = task1;
	task[0].currentState = ready;

//	task[1].stack_startAddr = TASK2_STACK_START;
	task[1].PSP = TASK2_STACK_START;
	task[1].pFun = task2;
	task[1].currentState = ready;

//	task[2].stack_startAddr = TASK3_STACK_START;
	task[2].PSP = TASK3_STACK_START;
	task[2].pFun = task3;
	task[2].currentState = ready;

//	task[3].stack_startAddr = TASK4_STACK_START;
	task[3].PSP = TASK4_STACK_START;
	task[3].pFun = task4;
	task[3].currentState = ready;

	task[4].PSP = IDLE_STACK_START;
	task[4].pFun = idle;
	task[4].currentState = ready;
}

uint32_t get_msp()
{
	return SCHEDULER_STACK_START;
}

__attribute__((naked))void scheduler_stack_init()
{
	__asm volatile("PUSH {LR}");
	__asm volatile("BL get_msp");
	__asm volatile("POP {LR}");
	__asm volatile("MSR MSP,R0");
	__asm volatile("BX LR");
}
uint32_t get_psp()
{
	return task[currentTask].PSP;
}

__attribute__((naked))void sp_to_psp()
{
	//Initialize PSP with task 1
	__asm volatile("PUSH {LR}");
	__asm volatile("BL get_psp");
	__asm volatile("POP {LR}");
	__asm volatile("MSR PSP,R0");

	//change to PSP as stack pointer for thread mode in unprivileged mode
	__asm volatile("MOV R0,#2");
	__asm volatile("MSR CONTROL,R0");

	__asm volatile("BX LR");

}

void dummy_stack_init()
{
	volatile uint32_t *ptr;
	for (uint8_t i = 0; i < MAX_TASK; i++)
	{
		ptr = (uint32_t*) task[i].PSP;
		ptr--;
		*ptr = XPSR;
		ptr--;
		*ptr = (uint32_t) task[i].pFun;
		ptr--;
		*ptr = LR;
		for (uint8_t j = 0; j < 13; j++)
		{
			ptr--;
			*ptr = 0;
		}
//		ptr--;
		task[i].PSP = (uint32_t) ptr;
	}
}

void systick_init()
{
	volatile sysTickContol_t *const pSYST_CSR = (sysTickContol_t*) SYST_CSR;
	volatile sysTickCount_t *const pSYST_RVR = (sysTickCount_t*) SYST_RVR;

	//systick enable
	pSYST_CSR->clockSource = 1;
	pSYST_CSR->systickCounterEnable = 1;
	pSYST_CSR->systickInterruptEnable = 1;

	//load count
	pSYST_RVR->count = (SYSTICK_COUNT - 1);
}

void set_psp(uint32_t psp)
{
	task[currentTask].PSP = psp;
}
void updateTask()
{
	state_e state = blocked;
	for (uint8_t i = 0; i < MAX_TASK; i++)
	{
		currentTask++;
		currentTask %= MAX_TASK;
		state=task[currentTask].currentState;
		if((state==ready)&&(currentTask!=(MAX_TASK-1)))
			break;
	}
	if(state==blocked)
		currentTask=(MAX_TASK-1);

}

__attribute__((naked)) void PendSV_Handler()
{
	__asm volatile("PUSH {LR}");
	__asm volatile("MRS R0,PSP");
	__asm volatile("STMDB R0!,{R4-R11}");
	__asm volatile("BL set_psp");

	__asm volatile("BL updateTask");
	__asm volatile("BL get_psp");
	__asm volatile("LDMIA R0!,{R4-R11}");
	__asm volatile("MSR PSP,R0");
	__asm volatile("POP {LR}");
	__asm volatile("BX LR");
}
void unblockTask()
{
	for (uint8_t i = 0; i < (MAX_TASK - 1); i++)
	{
		if (task[i].currentState != ready)
		{
			if (task[i].blockCount == global_count)
			{
				task[i].currentState = ready;
			}
		}
	}
}

void updateGlobalCount()
{
	global_count++;
}

void SysTick_Handler()
{
	updateGlobalCount();
	unblockTask();
	schedule();

}
void HardFault_Handler()
{
	printf("In the bus fault handler\n");
}
void MemManage_Handler()
{
	printf("In the memory manage fault handler\n");
}
void BusFault_Handler()
{
	printf("In the bus fault handler\n");
}
void UsageFault_Handler()
{
	printf("In the usage fault handler\n");
}
