/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include<stdio.h>
//#include <stdint.h>
#include "header.h"
#include"gpio.h"
void task1();
void task2();
void task3();
void task4();

uint32_t psp_of_task[MAX_TASK] =
{ T1_STACK_START, T2_STACK_START, T3_STACK_START, T4_STACK_START };

uint32_t taskHandlerAddress[MAX_TASK];
uint32_t currentTask = 0;

void enableSysytemFaultException();
__attribute__((naked)) void scheduler_stack_init(uint32_t shedulerStart);
__attribute__((naked)) void switch_sp_to_psp();
void task_stack_init();
void systick_init();
uint32_t getPSP();
void store_psp_value(uint32_t current_pspValue);

int main(void)
{
#if 0
	enableSysytemFaultException();
	scheduler_stack_init(SCHEDULER_TASK_START);
	taskHandlerAddress[0] = (uint32_t) task1;
	taskHandlerAddress[1] = (uint32_t) task2;
	taskHandlerAddress[2] = (uint32_t) task3;
	taskHandlerAddress[3] = (uint32_t) task4;

	task_stack_init();

	systick_init();

	switch_sp_to_psp();
	task1();
#endif
#if 0
	pinMode(1, output);
	pinMode(2, output);
	pinMode(3, output);
	pinMode(4, output);
//
	pinOutput(1, high);
	pinOutput(2, high);
	pinOutput(3, high);
	pinOutput(4, high);
#endif
	/* Loop forever */
	for (uint8_t i=0;i<7;i++)
	{
		pinMode(i, output);
		pinOutput(i, high);
	}
	for(;;);

}
void task1()
{
	while (1)
	{
		printf("In the task1\n");
	}
}
void task2()
{
	while (1)
	{
		printf("In the task2\n");
	}
}
void task3()
{
	while (1)
	{
		printf("In the task3\n");
	}
}
void task4()
{
	while (1)
	{
		printf("In the task4\n");
	}
}

void systick_init()
{
	volatile uint32_t *const pSYST_RVR = (uint32_t*) 0xE000E014; //SysTick Reload Value Register pointer
	uint32_t reqCount = ((CLOCK) * (REQUIRED_SYSTICK_DELAY));
	*pSYST_RVR &= ~(0x00ffffff);
	*pSYST_RVR |= (reqCount - 1); //set the count to SysTick register

	volatile uint32_t *const pSYST_CSR = (uint32_t*) 0xE000E010; //SysTick Control and Status Register pointer
	*pSYST_CSR |= (1 << 2); //clock source set to processor clock
	*pSYST_CSR |= (1 << 1);  //Enables SysTick exception request
	*pSYST_CSR |= (1 << 0); //SysTick enable

}

__attribute__((naked)) void scheduler_stack_init(uint32_t shedulerStart)
{
	__asm volatile("MSR MSP,%0"::"r"(shedulerStart));
	__asm volatile("BX LR");
}

__attribute__((naked)) void switch_sp_to_psp()
{
	//intialize PSP
	__asm volatile("PUSH {LR}");
	//push LR register to stack so that switch_sp_to_psp() can return to main()
	__asm volatile("BL getPSP");
	//call getPSP() to get current PSP value in R0 register
	__asm volatile("MSR PSP,R0");
	__asm volatile("POP {LR}");

	//change sp to psp
	__asm volatile("MOV R0,#0x02");
	__asm volatile("MSR CONTROL,R0");
	__asm volatile("BX LR");

}

void task_stack_init()
{
	//dummy stack initialization
	volatile uint32_t *pPSP;
	for (uint8_t i = 0; i < MAX_TASK; i++)
	{
		pPSP = (uint32_t*) psp_of_task[i];
		pPSP--;
		*pPSP = XPSR; //store PSR into private stack

		pPSP--;
		*pPSP = taskHandlerAddress[i]; //store task handler address to PC place in stack

		*pPSP--;
		*pPSP = LR; //store 0xFFFFFFFD into LR place in stack

		for (uint8_t j = 0; j < 13; j++)
		{
			pPSP--;
			*pPSP = 0;
		}
		psp_of_task[i] = (uint32_t) pPSP;

	}
}

void enableSysytemFaultException()
{
	volatile uint32_t *const pSHCRS = (uint32_t*) SHCRS;
	*pSHCRS |= (1 << 16); //memory fault
	*pSHCRS |= (1 << 17); //bus fault
	*pSHCRS |= (1 << 18); //usage fault
}
void MemManage_Handler()
{
	printf("In the memory fault\n");
}

void BusFault_Handler()
{
	printf("In the bus fault\n");
}
void HardFault_Handler()
{
	printf("In the hard fault\n");
}
void UsageFault_Handler()
{
	printf("In the usage fault\n");
}

uint32_t getPSP()
{
	return psp_of_task[currentTask]; //value will be returned in R0
}

void store_psp_value(uint32_t current_pspValue)
{
	psp_of_task[currentTask] = current_pspValue;
}

void update_next_task()
{
	currentTask++;
	currentTask %= MAX_TASK;
}
__attribute__((naked)) void SysTick_Handler()
{
	//store the context of current task
	//1.get the current psp value
	__asm volatile("MRS R0,PSP");

	//2.store r4-r11 into stack using psp value
	__asm volatile("STMDB R0!,{R4-R11}");

	__asm volatile("PUSH {LR}");
	//save LR before change
	//store the current PSP value
	__asm volatile("BL store_psp_value");

	//Retrieve the context of next task
	//1.Decide the next task to run
	__asm volatile("BL update_next_task");

	//2.get its PSP value
	__asm volatile("BL getPSP");
	//PSP value in R0

	//3.Using the PSP value retrieve the SF2(R4 to R11)
	__asm volatile("LDMIA R0!,{R4-R11}");

	//4.update PSP
	__asm volatile("MSR PSP,R0");

	__asm volatile("POP {LR}");
	__asm volatile("BX LR");

}
